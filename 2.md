## 개체(객체)나 배열을 **키 값**으로 사용할 때

일반 객체(Object 리터럴)는 **키를 문자열 또는 Symbol**로만 가진다.  
객체나 배열을 키로 쓰면 내부적으로 **문자열로 강제 변환(ToPropertyKey)** 되어 예상과 다르게 동작한다.

```js
const objKey = { x: 1, y: 2 };
const arrKey = [1, 2, 3];

const obj = {
  [objKey]: "1",
  [arrKey]: "2",
};

console.log(
  obj[objKey], // "1"
  obj[arrKey] // "2"
);

// 실제로는 이런 키로 저장됨
Object.keys(obj); // ["[object Object]", "1,2,3"]
```

즉, `objKey`/`arrKey` 자체가 **고유 키**로 쓰이는 게 아니라  
각각 `"[object Object]"`, `"1,2,3"` **문자열**로 치환되어 키가 된다.  
같은 형태의 다른 객체/배열도 **동일한 문자열**이 되면 충돌할 수 있다.

### ✅ 대안: `Map` 사용

`Map`은 **객체/배열/함수 등 모든 참조값을 키로** 안전하게 사용할 수 있다.

```js
const m = new Map();
const objK1 = { x: 1 };
const objK2 = { x: 1 };
const arrK = [1, 2, 3];

m.set(objK1, "O1");
m.set(objK2, "O2"); // 서로 다른 키로 취급
m.set(arrK, "A");

console.log(m.get(objK1)); // "O1"
console.log(m.get(objK2)); // "O2"
console.log(m.get(arrK)); // "A"
```

### ✅ 또 다른 대안: `Symbol`

충돌 없는 **고유 키**가 필요하면 `Symbol`을 사용한다.

```js
const ID = Symbol("id");
const user = { name: "범수", [ID]: 1234 };

console.log(user[ID]); // 1234
console.log(Object.keys(user)); // ["name"]  (심볼 키는 열거되지 않음)
```

---

## `delete` 연산자

객체의 **자체 프로퍼티**를 제거한다. (프로토타입의 프로퍼티는 삭제하지 못함)

```js
const person1 = { name: "김범수" };

delete person1.name; // true
console.log(person1); // {}
```

> 참고: `delete obj.x`의 반환값은 **성공 여부(Boolean)** 이다.  
> 비엄격 모드에서 `configurable: false`인 프로퍼티는 삭제 실패(`false`).

---

## 메서드(Method) – 객체의 **축약 메서드 정의**

### 일반 함수 프로퍼티

```js
const person = {
  name: "홍길동",
  salutate: function (formal) {
    return formal
      ? `안녕하세요, ${this.name} 입니다.`
      : `안녕하세요, ${this.name} 이에요.`;
  },
};
```

### 메서드 축약 표기(ES6)

```js
const person2 = {
  name: "홍길동",
  salutate(formal) {
    return formal
      ? `안녕하세요, ${this.name} 입니다.`
      : `안녕하세요, ${this.name} 이에요.`;
  },
};
```

- ES6부터 **축약 표기**로 정의된 함수만을 “메서드”라 부르는 경향이 있다.
- 차이점
  - 메서드 축약 표기로 선언된 함수는 `prototype` 프로퍼티가 없고 **`new`로 생성자 호출 불가**.
  - 내부적으로 `[[HomeObject]]`를 가져 **`super` 바인딩이 가능**(클래스 메서드에서 중요).
  - 동작 자체는 대부분 동일하나, OOP 상속 문맥에서 차이가 있다.

---

## 생성자 함수 (Constructor Function)

관례적으로 **대문자**로 시작한다.

```js
function BunsuChicken(name, no) {
  this.name = name;
  this.no = no;
  this.introduce = function () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다.`;
  };
}

const chain1 = new BunsuChicken("판교", 3);
const chain2 = new BunsuChicken("춘천", 4);
const chain3 = new BunsuChicken("군자", 5);
```

- `new`를 빼고 호출하면
  - **엄격 모드**: `this`가 `undefined` → 에러
  - 비엄격 모드: `this === globalThis` → 전역 오염 위험
- 생성자 함수는 기본적으로 `new`로 호출해서 **인스턴스(Instance)** 생성에 사용한다.

### ❓ this 안 쓰고 `return`으로 객체를 만들면 안 되나?

가능하다. 이를 **팩토리 함수(Factory Function)** 라고 한다.

```js
function makeChicken(name, no) {
  return {
    name,
    no,
    introduce() {
      return `안녕하세요, ${no}호 ${name}점입니다.`;
    },
  };
}

const store = makeChicken("판교", 3);
```

**차이점 요약**

- 생성자 함수: `new` 필요, 프로토타입 체인에 연결되어 `instanceof`/프로토타입 메서드 공유에 유리
- 팩토리 함수: `new` 불필요, 반환 객체가 **매번 새로 생성**, 프로토타입 공유를 직접 설계해야 함
- 리터럴 객체: 즉석에서 한 번 만들 때 사용

### `new` 누락 방지 패턴

```js
function BunsuChickenSafe(name, no) {
  if (!(this instanceof BunsuChickenSafe)) {
    return new BunsuChickenSafe(name, no);
  }
  this.name = name;
  this.no = no;
}
```

---

## 프로토타입(Prototype) – JS 객체지향의 핵심

인스턴스 간에 **메서드를 공유**하려면 생성자 안이 아니라 **프로토타입에** 메서드를 정의한다.

```js
function BunsuChicken(name, no) {
  this.name = name;
  this.no = no;
}

BunsuChicken.prototype.introduce = function () {
  return `안녕하세요, ${this.no}호 ${this.name}점입니다.`;
};

BunsuChicken.prototype.introEng = function () {
  return `Welcome to Bunsu Chicken at ${this.name}`;
};

const c = new BunsuChicken("판교", 3);
c.introduce(); // 프로토타입 메서드 공유
```

> 생성자 내부에 함수를 정의하면 인스턴스마다 **별도 함수가 복제**되어 메모리 낭비.

### 생성자 함수의 “정적” 필드/메서드

함수 객체 자체에 프로퍼티를 붙이면 **정적(static)처럼** 쓸 수 있다.

```js
BunsuChicken.brand = "범수치킨";
BunsuChicken.contact = function () {
  return `${this.brand}입니다. 무엇을 도와드릴까요?`;
};

BunsuChicken.contact(); // "범수치킨입니다. 무엇을 도와드릴까요?"
// (인스턴스에서는 호출 불가)
```

---

## 클래스(Class)

```js
class BunsuChicken {
  constructor(name, no) {
    this.name = name;
    this.no = no;
  }
  introduce() {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다.`;
  }

  // 정적 메서드
  static contact() {
    return "범수치킨입니다. 무엇을 도와드릴까요?";
  }
}

const chain = new BunsuChicken("판교", 3);
BunsuChicken.contact(); // 정적 메서드
```

- 클래스는 프로토타입 기반을 감싼 **Syntactic Sugar**.
- `new` 없이 호출하면 에러 (클래스 본문은 엄격 모드).
- 메서드는 자동으로 **프로토타입**에 올라간다.

### 필드(Field), `static`, `#private`, getter/setter

```js
class Slime {
  hp = 50; // 퍼블릭 인스턴스 필드
  op = 4;
  static species = "SLIME"; // 정적 필드
  #secret = 7; // 프라이빗 필드

  get power() {
    return this.op;
  }
  set power(v) {
    this.op = v;
  }

  attack(enemy) {
    enemy.hp -= this.op;
    this.hp += this.op / 4;
  }

  static info() {
    return this.species;
  }
}
```

### 상속과 `super`

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    return `${this.name}가 소리를 냅니다.`;
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // 부모 초기화
  }
  speak() {
    return `${super.speak()} 멍멍!`;
  }
}
```

---

## 스프레드(Spread)와 복사 깊이

```js
const obj1 = { x: 1, y: { a: 2 }, z: [3, 4] };
const obj2 = { ...obj1 };

obj1.x++; // obj2.x는 그대로
obj1.y.a++; // ❗ obj2.y.a도 변함 (얕은 복사)
obj1.z[0]++; // ❗ obj2.z[0]도 변함
```

- 스프레드는 **얕은 복사(shallow copy)** 이다.
- 깊은 복사(Deep copy)가 필요하면 `structuredClone(obj)`, `_.cloneDeep(obj)`(lodash) 등을 사용.

---

## 주요 빌트인과 전역

### 전역 객체

- 브라우저: `window`, Node.js: `global`, 공통: `globalThis`

```js
console.log(globalThis === globalThis.globalThis); // true
```

### 전역 프로퍼티/함수 예시

- 프로퍼티: `Infinity`, `NaN`, `undefined`
- 함수: `isNaN`, `isFinite`, `parseInt`, `parseFloat`, `encodeURI`, `encodeURIComponent`, `eval`(권장 X)

```js
// 안전한 숫자 판별
isFinite(null); // true (null -> 0으로 변환)
Number.isFinite(null); // false (숫자 타입만 true)

isNaN("abc"); // true (숫자로 변환 시 NaN)
Number.isNaN("abc"); // false (숫자 타입의 NaN만 true)
```

### Number 주요 API

- 정적 프로퍼티: `EPSILON`, `MAX_VALUE`, `MIN_VALUE`, `MAX_SAFE_INTEGER`, `MIN_SAFE_INTEGER`, `NaN`, `POSITIVE_INFINITY`, `NEGATIVE_INFINITY`
- 인스턴스 메서드(문자열 반환): `toExponential`, `toFixed`, `toPrecision`, `toString(base)`

```js
(123.456789).toExponential(2); // "1.23e+2"
(123.456789).toFixed(1); // "123.5"
(11).toString(2); // "1011"
```

### Math 주요 API

- 상수: `Math.PI`, `Math.E`
- 메서드: `abs`, `ceil`, `floor`, `round`, `trunc` 등

```js
// 부동소수점 비교 보정
const isEqual = (a, b) => Math.abs(a - b) < Number.EPSILON;
isEqual(0.1 + 0.2, 0.3); // true (실무에선 보통 decimal 라이브러리 권장)
```
