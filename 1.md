자바스크립트는 파이썬이나 루비처럼 **인터프리터 언어**입니다.

개발과정이 빠르지만 버그가 많이 생길 수 있다. 그리고 동적 자료형을 가져 코딩 규칙을 덜 깐깐하게 가지게 됩니다. 하지만 오류의 여지를 발견할 수 있다.

Babel이라는 코드 변환 소프트웨어를 사용해 최신js문법을 예전 js문법으로 사용해서 업데이트 안된 브라우저를 사용할 수 있따.

`let x=1`
`let x=2`
`이렇게 선언하면 syntaxError가 난다.`
`but, var는 가능했다 var가 좋고 유연한게 아니라 잘못 만들어진...`

\*\* 선언하기 전 코드를 사용할 수 없음!

\*\* undefined는 있는값이다

\*\* null도 값이 있는데 정하지 않았따 - 의도적인 빈 값을의미

**null은 object(객체)등이 들어있거나 반환되어야 하지만 없을 때 주로 사용**

null은 typeof시 object로 나온다. 설계를 잘못했다. 이걸 고치면 예전에 만든 웹사이트가 오류가 생겨서 그렇다

null 여부 확인은 === null로 확인

# 📘 JavaScript 핵심 정리

## ✅ 상수 (constant)

`const`는 constant(상수)의 약자이다.  
JavaScript는 **동적 타입 언어**이므로, 변수의 자료형은 실행 중에도 바뀔 수 있다.

```js
let age = 17;
typeof age; // "number"

age = "열일곱";
typeof age; // "string"
```

즉, JavaScript의 변수는 **동적으로 자료형이 변한다.**

---

## ✅ 수학 함수와 제곱 연산자

```js
Math.pow(10, 2); // 100
10 ** 2; // 100 (ES6 이후 제곱 연산자)
```

---

## ✅ 부동소수점 계산 오차

```js
0.1 + 0.2 !== 0.3;
```

이는 **컴퓨터가 이진법으로 실수를 표현하기 때문**이다.  
정확한 계산이 필요하다면 `decimal.js`, `big.js` 등의 **라이브러리** 사용을 권장한다.

---

## ✅ Boolean과 비교 연산자

| 비교식             | 결과  | 설명                        |
| ------------------ | ----- | --------------------------- |
| 0 == false         | true  | 동등 비교는 타입 변환 발생  |
| 0 === false        | false | 일치 비교는 타입까지 비교   |
| '' == false        | true  | 빈 문자열은 falsy로 간주    |
| '' === false       | false | 타입이 달라 false           |
| null == false      | false | null은 false와 다름         |
| undefined == false | false | undefined도 다름            |
| NaN == false       | false | NaN은 어떤 값과도 같지 않음 |

---

## ✅ Null 병합 연산자 (`??`)

`||`는 falsy 값 전체를 대체하지만,  
`??`는 **`null` 또는 `undefined`만** 대체한다.

```js
let name = null;
let displayName = name ?? "기본 이름"; // "기본 이름"
```

---

## ✅ 병합 할당 연산자

```js
let x = 0;
let y = "";
let z = null;

x ||= 100; // falsy이면 100 대입 → 100
y &&= "있어야 바뀜"; // falsy라서 그대로 '' 유지
z ??= "기본값"; // null이라 '기본값' 대입
```

---

## ✅ 참조 타입과 원시 타입

### 📍 원시 타입

`number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`  
→ 값 자체를 복사한다.

```js
let num1 = 1;
let num2 = num1;
num2 = 2;

console.log(num1, num2); // 1, 2
```

### 📍 참조 타입

`object`, `array`, `function`  
→ **메모리 주소를 복사**하므로 같은 객체를 참조한다.

```js
const obj1 = { name: "김범수" };
const obj2 = obj1;

obj2.name = "김범수수수퍼노바";

console.log(obj1, obj2); // 둘 다 { name: '김범수수수퍼노바' }
```

---

## ✅ 비교 연산자 ‘==’ vs ‘===’

- `==`: 자료형이 다르면 자동 변환 후 비교
- `===`: 자료형 변환 없이 값과 타입 모두 비교

```js
0 == "0"; // true
0 === "0"; // false
```

---

## ✅ 스코프 (Scope)

| 구분          | 특징                                            |
| ------------- | ----------------------------------------------- |
| 전역 스코프   | 프로그램 전체에서 접근 가능, 종료 시 소멸       |
| 지역 스코프   | 블록 `{}` 내에서만 접근 가능, 블록 종료 시 소멸 |
| 스코프 체이닝 | 내부 스코프에서 변수 탐색 시 외부로 확장 검색   |

```js
let x = 10;

{
  let y = 20;
  console.log(x); // 10 (외부 접근 가능)
}

console.log(y); // ❌ ReferenceError
```

> `var`는 함수 스코프(function scope)만 갖기 때문에 블록 밖에서도 접근 가능하다.

---

## ✅ 제어문

### if / else

조건에 따라 실행할 코드 분기.

```js
if (score >= 90) return "A";
else return "B";
```

### switch

여러 경우의 분기를 효율적으로 표현.

```js
switch (fruit) {
  case "apple":
    console.log("사과");
    break;
  case "banana":
    console.log("바나나");
    break;
  default:
    console.log("기타 과일");
}
```

> `break`가 없으면 **fall-through 현상**이 발생한다.

---

## ✅ 반복문 (Loops)

### 일반 for문

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

### 무한 루프

```js
for (;;) {
  // 조건이 없으면 무한 반복
}
```

### 객체와 배열 반복

#### `for...in` → 객체용

```js
const lunch = { name: "라면", taste: "매운맛" };

for (const key in lunch) {
  console.log(key, ":", lunch[key]);
}
```

#### `for...of` → 배열, 문자열 등 **이터러블(Iterable)**용

```js
const list = [1, "가나다", false, null];
for (const item of list) {
  console.log(item);
}

for (const letter of "안녕하세요~") {
  console.log(letter);
}
```

#### 장점

- `for...of`는 인덱스를 다루지 않아 안전하다.
- 원본 배열을 직접 수정하지 않는다.

---

### break / continue / label

```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 1) continue outer;
    console.log(i, j);
  }
}
```

---

### do...while

조건과 상관없이 **최소 한 번 실행**된다.

```js
let i = 0;
do {
  console.log(i++);
} while (i < 3);
```

---

## ✅ 함수 (Function)

### 개념

- 반복되는 작업을 정의
- 입력값(Input)을 받아 출력값(Output)을 반환
- 외부 상태에 의존하지 않도록 설계할 것 (순수 함수)

---

### 함수 선언과 호출 순서

함수 선언문은 **호이스팅**되지만,  
함수를 변수나 상수에 대입하거나 화살표 함수를 쓸 경우 호이스팅되지 않는다.

---

### 화살표 함수

```js
const add = (a, b) => a + b;
```

- 간결한 표현식
- 블록이 없는 경우 `return` 생략 가능
- `this` 바인딩이 없음 → 객체 메서드로는 부적절

---

## ✅ 일급 객체 (First-Class Object)

자바스크립트에서 함수는 **값처럼 다뤄질 수 있는 객체**이다.

```js
function add(a, b) {
  return a + b;
}

console.log(typeof add); // "function"
console.log(add instanceof Object); // true
```

### 특징

- 변수/상수에 할당 가능
- 다른 함수의 인자로 전달 가능 (콜백)
- 다른 함수의 결과로 반환 가능 (고차 함수)

---

### 고차 함수와 콜백 함수

```js
function doInArray(array, func) {
  for (const item of array) func(item);
}

doInArray([1, 2, 3], console.log);
```

`doInArray` → 고차 함수  
`console.log` → 콜백 함수

---

## ✅ 커링 (Currying)

인자를 하나씩 받아 여러 단계에 걸쳐 함수를 반환하는 형태.

```js
const curryAddMultSub = (a) => (b) => (c) => (d) => (a + b) * c - d;

curryAddMultSub(2)(3)(4)(5); // 15
```

---

## ✅ 함수형 클린 코드 원칙

- 한 함수는 **한 가지 일만** 수행
- 입력값만 다루고 외부 상태 변경 금지
- 원본 데이터 변경 대신 새 데이터 반환

---

## ✅ 매개변수

### 기본값

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}`);
}
```

### arguments 객체

- 함수 내부에서 접근 가능 (유사 배열)

```js
function logAll() {
  console.log(arguments);
}
logAll(1, 2, 3); // [1, 2, 3]
```

### 나머지 매개변수(Rest Parameter)

```js
function sum(...nums) {
  return nums.reduce((a, b) => a + b);
}
```

---

## ✅ 재귀함수 (Recursion)

```js
function upto5(x) {
  console.log(x);
  if (x < 5) upto5(x + 1);
  else console.log("---");
}
```

> 자기 자신을 호출하면서 스택이 쌓임 → 너무 깊으면 **Stack Overflow** 발생.

---

### 팩토리얼 예제

```js
function fact(x) {
  return x === 0 ? 1 : x * fact(x - 1);
}
```

---

## ✅ 즉시 실행 함수 (IIFE)

```js
(function () {
  console.log("IIFE 실행");
})();
```

- 한 번만 실행되는 함수
- 전역 변수 오염 방지
- 스코프 충돌 방지

---

## ✅ 불변성 (Immutability)

```js
let x = 1;
let y = { name: "홍길동", age: 15 };
let z = [1, 2, 3];

function changeValue(a, b, c) {
  a++;
  b.name = "전우치";
  b.age++;
  c[0]++;
}

changeValue(x, y, z);

console.log(x, y, z);
// 1, { name: '전우치', age: 16 }, [2, 2, 3]
```

| 타입      | 함수 내부 변경 영향 | 이유            |
| --------- | ------------------- | --------------- |
| 원시 타입 | ❌ 없음             | 값 복사         |
| 참조 타입 | ✅ 있음             | 주소(참조) 복사 |

---

## ✅ 객체(Object)와 클래스(Class)

### 식별자 규칙 위반 키

변수명으로 사용할 수 없는 키는 문자열로 감싸야 한다.

```js
const obj = {
  1: "하나",
  "ab-cd": "abcd",
  "s p a c e": "space",
};
```

---

## ✅ 요약

- JavaScript는 **동적 타입 언어**
- 원시타입은 값 복사, 참조타입은 주소 복사
- `==`와 `===`의 차이는 **형 변환 여부**
- 스코프는 **블록 단위**, 함수는 **일급 객체**
- **함수형 프로그래밍** 지향: 불변성, 순수 함수, 고차 함수
- **IIFE, 커링, Rest, 재귀** 등은 고급 문법 핵심
